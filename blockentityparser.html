<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vintage Story BlockEntity Parser</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 20px; background: #f0f2f5; color: #333; }
        .container { max-width: 1000px; margin: auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        h2 { margin-top: 0; color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 15px; }
        .upload-section { background: #f8f9fa; border: 2px dashed #ccd1d9; padding: 20px; text-align: center; border-radius: 8px; margin-bottom: 20px; transition: 0.3s; }
        .upload-section:hover { border-color: #4CAF50; background: #f1f9f1; }
        #output { background: #282c34; color: #abb2bf; padding: 20px; border-radius: 6px; overflow-x: auto; white-space: pre-wrap; min-height: 300px; font-family: 'Cascadia Code', 'Fira Code', monospace; font-size: 13px; line-height: 1.5; border: 1px solid #181a1f; }
        .status-msg { margin: 10px 0; font-weight: bold; }
        .error { color: #d9534f; }
        .success { color: #5cb85c; }
    </style>
</head>
<body>

<div class="container">
    <h2>Vintage Story BlockEntity Parser</h2>
    <p>Upload a JSON containing <code>BlockEntities</code>. It will decode the first entity found.</p>
    
    <div class="upload-section">
        <input type="file" id="jsonFileInput" accept=".json">
        <div id="status" class="status-msg"></div>
    </div>

    <div id="output">// Results will appear here...</div>
</div>

<script>
const Ascii85 = {
    c_first: 33, // '!'
    c_last: 117,  // 'u'
    s_powers: [52200625, 614125, 7225, 85, 1],

    decode(encoded) {
        // Clean string: remove whitespace and the <~ ~> wrappers if present
        encoded = encoded.replace(/\s/g, "");
        if (encoded.startsWith("<~")) encoded = encoded.substring(2);
        if (encoded.endsWith("~>")) encoded = encoded.substring(0, encoded.length - 2);

        let decodedBytes = [];
        let count = 0;
        let value = 0;

        for (let i = 0; i < encoded.length; i++) {
            let ch = encoded.charCodeAt(i);

            if (ch === 122) { // 'z'
                if (count !== 0) throw new Error("Character 'z' invalid inside an Ascii85 block.");
                this.pushValue(decodedBytes, 0, 0);
                // Reset for next block
                count = 0;
                value = 0;
            } else if (ch >= this.c_first && ch <= this.c_last) {
                value += (ch - this.c_first) * this.s_powers[count];
                count++;

                if (count === 5) {
                    this.pushValue(decodedBytes, value, 0);
                    count = 0;
                    value = 0;
                }
            }
        }

        if (count > 0) {
            if (count === 1) throw new Error("The final Ascii85 block must contain more than one character.");
            let padding = 5 - count;
            for (let i = count; i < 5; i++) {
                value += 84 * this.s_powers[i];
            }
            this.pushValue(decodedBytes, value, padding);
        }

        return new Uint8Array(decodedBytes).buffer;
    },

    pushValue(arr, value, padding) {
        arr.push((value >>> 24) & 0xFF);
        if (padding === 3) return;
        arr.push((value >>> 16) & 0xFF);
        if (padding === 2) return;
        arr.push((value >>> 8) & 0xFF);
        if (padding === 1) return;
        arr.push(value & 0xFF);
    }
};

class TreeAttributeParser {
    constructor(buffer) {
        this.view = new DataView(buffer);
        this.offset = 0;
        this.decoder = new TextDecoder();
    }

    readString() {
        let length = 0, shift = 0;
        while (this.offset < this.view.byteLength) {
            let byte = this.view.getUint8(this.offset++);
            length |= (byte & 0x7f) << shift;
            if ((byte & 0x80) === 0) break;
            shift += 7;
        }
        if (length === 0) return "";
        const strBytes = new Uint8Array(this.view.buffer, this.offset, length);
        this.offset += length;
        return this.decoder.decode(strBytes);
    }

    parse() {
        const result = {};
        while (this.offset < this.view.byteLength) {
            const attrId = this.view.getUint8(this.offset++);
            if (attrId === 0) break;
            const key = this.readString();
            result[key] = this.readAttribute(attrId);
        }
        return result;
    }

    readAttribute(id) {
        switch (id) {
            case 1: { const v = this.view.getInt32(this.offset, true); this.offset += 4; return v; }
            case 2: { const v = this.view.getBigInt64(this.offset, true); this.offset += 8; return v.toString(); }
            case 3: { const v = this.view.getFloat64(this.offset, true); this.offset += 8; return v; }
            case 4: { const v = this.view.getFloat32(this.offset, true); this.offset += 4; return v; }
            case 5: return this.readString();
            case 6: return this.parse();
            case 8: {
                const len = this.view.getInt32(this.offset, true); this.offset += 4;
                const arr = new Uint8Array(this.view.buffer, this.offset, len);
                this.offset += len; return Array.from(arr);
            }
            case 9: return this.view.getUint8(this.offset++) !== 0;
            case 10: {
                const len = this.view.getInt32(this.offset, true); this.offset += 4;
                return Array.from({length: len}, () => this.readString());
            }
            case 11: {
                const len = this.view.getInt32(this.offset, true); this.offset += 4;
                const arr = [];
                for(let i=0; i<len; i++) { arr.push(this.view.getInt32(this.offset, true)); this.offset += 4; }
                return arr;
            }
            default: return `[Type ${id} unknown]`;
        }
    }
}

document.getElementById('jsonFileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    const status = document.getElementById('status');
    const output = document.getElementById('output');

    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const json = JSON.parse(event.target.result);
            if (!json.BlockEntities) throw new Error("Missing 'BlockEntities' field.");

            const entities = Object.entries(json.BlockEntities);
            if (entities.length === 0) throw new Error("No entries in BlockEntities.");

            // Extract the first entity's data
            const entityData = entities[0][1];
            const asciiString = typeof entityData === 'string' ? entityData : (entityData.Data || entityData.Attributes);

            if (!asciiString) throw new Error("No Ascii85 string found in entity.");

            const binaryData = Ascii85.decode(asciiString);
            const parser = new TreeAttributeParser(binaryData);
            const result = parser.parse();
            
            status.innerHTML = `<span class="success">Parsed ${entities[0][0]}</span>`;
            output.textContent = JSON.stringify(result, null, 4);

        } catch (err) {
            console.error(err);
            status.innerHTML = `<span class="error">${err.message}</span>`;
            output.textContent = err.stack;
        }
    };
    reader.readAsText(file);
});
</script>
</body>
</html>